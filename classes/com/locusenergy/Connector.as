package com.locusenergy {		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.NetStatusEvent;	import flash.events.SecurityErrorEvent;	import flash.net.*;	import flash.display.Sprite;		public class Connector extends EventDispatcher{				// Public Properties:		public var connection:NetConnection;		public var completeFunctionArray:Array;		public var gateway:String;		public var componentPath:String;		public var componentList:XMLList;		public var xml:XML;		public var resultArray:Array;		// Private Properties:		private var resultValueArray:Array;		private var resultLabelArray:Array;		private var componentFunctions:Array;		private var tempName:String;		private var completeFunction:Function = null;		private var params;		private var listenerArray:Array;		private var responder:Responder 		private var loader:URLLoader;		private var faultCount = 0;		private var currCall = null;		private var cancelPrevious = false;			// Initialization:		public function Connector() 		{			listenerArray = new Array();			completeFunctionArray = new Array();		}		public function loadConfig()		{			loader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.TEXT;			loader.addEventListener(Event.COMPLETE, loadConfigInfo, false, 0, true);			listenerArray.push({obj: loader, type: Event.COMPLETE, listener: loadConfigInfo});			loader.load(new URLRequest("../config/config.xml"));		}		public function loadConfigAndConnect()		{			loader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.TEXT;			loader.addEventListener(Event.COMPLETE, loadConfigInfoAndConnect, false, 0, true);			listenerArray.push({obj: loader, type: Event.COMPLETE, listener: loadConfigInfoAndConnect});			loader.load(new URLRequest("../config/config.xml"));					}		private function loadConfigInfoAndConnect(e)		{			//loader.removeEventListener(Event.COMPLETE, loadConfigInfoAndConnect);			loadConfigInfo(e);			connectToGateway();		}		public function loadConfigInfo(evt: Event)		{			//if (loader.hasEventListener(Event.COMPLETE))				//loader.removeEventListener(Event.COMPLETE, loadConfigInfo);			xml = new XML(evt.target.data);			gateway = xml.gateway.@address;			componentPath = xml.components.@path;			componentList = xml.components.component;			dispatchEvent(new Event(Event.COMPLETE));					}		public function getComponentData(myName:String, completeFunction:Function = null, parameters = null)		{			cancelPrevious = true;			trace('CANCEL PREVIOUS', cancelPrevious);						this.completeFunction = completeFunction;			//trace("GATEWAY", gateway, connection, completeFunctionArray.length, completeFunction);			this.params = parameters;			if (gateway == null)			{				tempName = myName;				loadConfig();				this.addEventListener(Event.COMPLETE, getCompDataAfterLoad, false, 0, true);				listenerArray.push({obj:this, type: Event.COMPLETE, listener: getCompDataAfterLoad});			}			else			{				//completeFunctionArray.push(completeFunction);				if (connection == null)				{					connectToGateway();				}								runThis(myName);			}		}				public function postData(apiCall, completeFunction:Function = null, parameters = null)		{			trace("---- KioskMonitor API Call ----");			this.completeFunction = completeFunction;						//responder = new Responder(postSuccess, postFault);						//Kiosk Monitor Post Data									if(currCall == null)			{				trace("call:     kiosk monitor api", componentPath + "." + apiCall);				currCall = apiCall;				makeApiCall(apiCall, parameters);			}			else			{				trace("pause:    watiing for all clear");							}						dispatchEvent(new Event("API Called"));			//completeFunction.call();		}		function makeApiCall(apiCall, parameters)		{			responder = new Responder(postSuccess, postFault);				connection.call(componentPath + "." + apiCall, responder, parameters);					}		/*		* Source of instability - possibly remnants of old code		* Keep here just in case.		*/		public function postSuccess(e)		{			currCall = null;			dispatchEvent(new Event("API Success"));			if (this.completeFunction != null)				this.completeFunction.call();		}		public function postFault(e)		{			currCall = null;			dispatchEvent(new Event("API Fail"));			trace("Fault in Post", e.type);		}				private function runThis(myName)		{			var myType = componentList.(@name == myName).attribute("type");						if (myType == "Module" || myType == "Panel")			{				//trace("-----Loading data for module / panel");				loadModuleData( componentList.(@name == myName).functions, componentList.(@name == myName).attribute("componentName"));			}			else if (myType == "BarChart" || myType == "LineChart")			{				//trace("-----Loading data for chart");				//Gets the settings from the myType config which corresponds to the chartType				loadModuleData( componentList.(@name == myType).functions, componentList.(@name == myName).attribute("componentName"));			}		}				private function getCompDataAfterLoad(e)		{			//this.removeEventListener(Event.COMPLETE, getCompDataAfterLoad);			getComponentData(tempName, this.completeFunction, params);		}						private function loadModuleData(xml, componentName)		{			resultValueArray = new Array();			resultLabelArray = new Array();			componentFunctions = new Array();						trace("\n---- Loading component functions for ", componentPath + "." + componentName, "-----");			for each (var func in xml.func)			{				//responder = new Responder(getResult, onFault);				resultLabelArray.push(func.attribute("returns").toString());				trace("function:", func.text());				componentFunctions.push(componentPath + "." + componentName + "." + func.text());				//connection.call(componentPath + "." + componentName + "." + func.text(), responder, parameters);											}			trace("\n---- Starting function calls -----")			if(currCall == null)				recursiveCall();			else			{				trace("\n** waiting for previous call to complete", componentFunctions.length, '**\n');			}					}						private function recursiveCall()		{			cancelPrevious = false;			var func = componentFunctions.shift();			currCall = func;			responder = new Responder(getResult, onFault);			trace("call:     ", func);			connection.call(func, responder, params);		}				private function getResult(response)		{			currCall = null;			if(!cancelPrevious)			{				resultValueArray.push(response);				trace("response: ", response,  "(" + resultValueArray.length + '/' + resultLabelArray.length + ")");				if(	resultLabelArray.length == resultValueArray.length)				{					publishResults();				}				else					recursiveCall();			}			else			{				trace("Previous Call terminated, restart new call", componentFunctions.length);				recursiveCall();			}		}		public function onFault(e)		{			faultCount++;			trace("\n************************* FAULT *************************");			try			{				recursiveTrace(e);			}			catch( e:Error )			{				trace( e );			}			trace("**********************************************************\n")						currCall = null;						if(!cancelPrevious)			{				resultValueArray.push(null);				if(	resultLabelArray.length <= resultValueArray.length)				{					publishResults();				}				else					recursiveCall();			}			else			{				trace("Previous Call terminated on fault, restart new call", componentFunctions.length);				recursiveCall();			}		}		private function recursiveTrace(obj)		{			for( var i in obj )			{				objectRecursion(obj[i], i);			}					}		private function objectRecursion(obj, i)		{			if(obj is Object)				recursiveTrace(obj);			trace( i + ":", obj);		}				private function publishResults()		{				if(!cancelPrevious)			{				trace("\n---- Publish Results ----\n");				resultArray = new Array(resultLabelArray, resultValueArray);				//readResults();				dispatchEvent(new Event("ComponentDataLoaded"));				if (completeFunction != null) completeFunction.call();				//runCompleteFunction();			}		}/*		private function runCompleteFunction()		{			for each (var a in completeFunctionArray)			{				if (a != null)					trace (a.toString());				else					trace (a);			}			var func:Function;			if (completeFunctionArray.length >= 1) func = completeFunctionArray.shift();			if (func != null) func();		}*/		private function readResults()		{			trace("-----------------------------------------");			for (var i in resultArray)			{				trace("res:",i, resultArray[i][0], resultArray[i][1], resultArray[i][2]);			}			trace("-----------------------------------------");					}		public function connectToGateway()		{			if (connection != null && connection.connected)			{				trace("Killing connection left open")				connection.close();			}						connection = new NetConnection();			connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler, false, 0, true);			listenerArray.push({obj: connection, type: NetStatusEvent.NET_STATUS, listener: netStatusHandler});			connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler, false, 0, true);			listenerArray.push({obj: connection, type: SecurityErrorEvent.SECURITY_ERROR, listener: securityErrorHandler});			connection.objectEncoding=ObjectEncoding.AMF0;			trace("Opening Gateway", gateway);			connection.connect(gateway);			dispatchEvent(new Event("Connected"));		}		private function netStatusHandler(event:NetStatusEvent):void {			trace("Event",event.info.code);									dispatchEvent(event);						switch (event.info.code) {                case "NetConnection.Connect.Success"	:	trace("Status: Connected.");															//runThis();                    										break;                case "NetConnection.Connect.Rejected"	:	trace("The connection attempt did not have permission to access the application.");                    										break;																		case "NetConnection.Connect.Failed"		:	trace("The connection attempt failed.");                    										break;				case "NetConnection.Call.Failed"		:	trace("The NetConnection.call method was not able to invoke the server-side method or command.");                    										dispatchEvent(new Event("NetConnectionError"));															break;				case ""									:																break;				default									:	trace("Event",event.info.code);															break;															            }        }        private function securityErrorHandler(event:SecurityErrorEvent):void {            trace("securityErrorHandler: " + event);        }				public function close()		{			trace("Killing connection")			connection.close();		}				public function cleanUp()		{			removeEventListeners();		}		private function removeEventListeners()		{/*			try			{				if (connection.hasEventListener(Event.COMPLETE))					connection.removeEventListener(Event.COMPLETE, loadConfigInfo);				if (connection.hasEventListener(Event.COMPLETE))					connection.removeEventListener(Event.COMPLETE, loadConfigInfoAndConnect);			 				if (connection.hasEventListener(Event.COMPLETE))					connection.removeEventListener(Event.COMPLETE, getCompDataAfterLoad);									 				if (connection.hasEventListener(NetStatusEvent.NET_STATUS))					connection.removeEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);				if (connection.hasEventListener(SecurityErrorEvent.SECURITY_ERROR))					connection.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);			}			catch(error:Error)			{				trace("Connection Cleanup Error:", error);			}*/			//trace("Cleaning Connector")			for(var i in listenerArray)			{				//trace("Removing:", listenerArray[i].type, "from", listenerArray[i].obj);				listenerArray[i].obj.removeEventListener(listenerArray[i].type, listenerArray[i].listener);			}		}		// Public Methods:		// Protected Methods:	}	}