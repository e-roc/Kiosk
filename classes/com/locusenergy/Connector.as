package com.locusenergy {		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.NetStatusEvent;	import flash.events.SecurityErrorEvent;	import flash.net.*;	import flash.display.Sprite;		public class Connector extends EventDispatcher{				// Public Properties:		public var connection:NetConnection;		public var completeFunctionArray:Array;		public var gateway:String;		public var componentPath:String;		public var componentList:XMLList;		public var xml:XML;		public var resultArray:Array;		// Private Properties:		private var resultValueArray:Array;		private var resultLabelArray:Array;		private var tempName:String;		private var completeFunction:Function = null;		private var params;		private var listenerArray:Array;		private var responder:Responder 		private var loader:URLLoader;		private var faultCount = 0;		private var currCall;			// Initialization:		public function Connector() 		{			listenerArray = new Array();			completeFunctionArray = new Array();		}		public function loadConfig()		{			loader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.TEXT;			loader.addEventListener(Event.COMPLETE, loadConfigInfo, false, 0, true);			listenerArray.push({obj: loader, type: Event.COMPLETE, listener: loadConfigInfo});			loader.load(new URLRequest("../config/config.xml"));		}		public function loadConfigAndConnect()		{			loader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.TEXT;			loader.addEventListener(Event.COMPLETE, loadConfigInfoAndConnect, false, 0, true);			listenerArray.push({obj: loader, type: Event.COMPLETE, listener: loadConfigInfoAndConnect});			loader.load(new URLRequest("../config/config.xml"));					}		private function loadConfigInfoAndConnect(e)		{			//loader.removeEventListener(Event.COMPLETE, loadConfigInfoAndConnect);			loadConfigInfo(e);			connectToGateway();		}		public function loadConfigInfo(evt: Event)		{			//if (loader.hasEventListener(Event.COMPLETE))				//loader.removeEventListener(Event.COMPLETE, loadConfigInfo);			xml = new XML(evt.target.data);			gateway = xml.gateway.@address;			componentPath = xml.components.@path;			componentList = xml.components.component;			dispatchEvent(new Event(Event.COMPLETE));					}		public function getComponentData(myName:String, completeFunction:Function = null, parameters = null)		{			this.completeFunction = completeFunction;			//trace("GATEWAY", gateway, connection, completeFunctionArray.length, completeFunction);			this.params = parameters;			if (gateway == null)			{				tempName = myName;				loadConfig();				this.addEventListener(Event.COMPLETE, getCompDataAfterLoad, false, 0, true);				listenerArray.push({obj:this, type: Event.COMPLETE, listener: getCompDataAfterLoad});			}			else			{				//completeFunctionArray.push(completeFunction);				if (connection == null)				{					connectToGateway();				}				runThis(myName);			}		}		public function postData(apiCall, completeFunction:Function = null, parameters = null)		{			this.completeFunction = completeFunction;			trace("API CALL");			responder = new Responder(postSuccess, postFault);			connection.call(componentPath + "." + apiCall, responder, parameters);			dispatchEvent(new Event("API Called"));		}		public function postSuccess(e)		{			dispatchEvent(new Event("API Success"));			if (this.completeFunction != null)				this.completeFunction.call();		}		private function runThis(myName)		{			var myType = componentList.(@name == myName).attribute("type");			if (myType == "Module" || myType == "Panel")				loadModuleData( componentList.(@name == myName).functions, componentList.(@name == myName).attribute("componentName"), params);			else if (myType == "BarChart" || myType == "LineChart")			{				//Gets the settings from the myType config which corresponds to the chartType				loadModuleData( componentList.(@name == myType).functions, componentList.(@name == myName).attribute("componentName"), params);			}		}				private function getCompDataAfterLoad(e)		{			//this.removeEventListener(Event.COMPLETE, getCompDataAfterLoad);			getComponentData(tempName, this.completeFunction, params);		}				private function loadModuleData(xml, componentName, parameters = null)		{			resultValueArray = new Array();			resultLabelArray = new Array();			for each (var func in xml.func)			{				currCall = func + " " + componentName;				responder = new Responder(getResult, onFault);				resultLabelArray.push(func.attribute("returns").toString());				connection.call(componentPath + "." + componentName + "." + func.text(), responder, parameters);			}					}		private function getResult(response)		{			resultValueArray.push(response);			if(	resultLabelArray.length == resultValueArray.length)			{				publishResults();			}		}		private function publishResults()		{				//trace("Publish Results", currCall);			resultArray = new Array(resultLabelArray, resultValueArray);			//readResults();			dispatchEvent(new Event("ComponentDataLoaded"));			if (completeFunction != null) completeFunction.call();			//runCompleteFunction();					}/*		private function runCompleteFunction()		{			for each (var a in completeFunctionArray)			{				if (a != null)					trace (a.toString());				else					trace (a);			}			var func:Function;			if (completeFunctionArray.length >= 1) func = completeFunctionArray.shift();			if (func != null) func();		}*/		private function readResults()		{			trace("-----------------------------------------");			for (var i in resultArray)			{				trace("res:",i, resultArray[i][0], resultArray[i][1], resultArray[i][2]);			}			trace("-----------------------------------------");					}		public function connectToGateway()		{			if (connection != null && connection.connected)			{				trace("Killing connection left open")				close();			}						connection = new NetConnection();			connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler, false, 0, true);			listenerArray.push({obj: connection, type: NetStatusEvent.NET_STATUS, listener: netStatusHandler});			connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler, false, 0, true);			listenerArray.push({obj: connection, type: SecurityErrorEvent.SECURITY_ERROR, listener: securityErrorHandler});			connection.objectEncoding=ObjectEncoding.AMF0;			trace("Opening Gateway", gateway);			connection.connect(gateway);			dispatchEvent(new Event("Connected"));		}		private function netStatusHandler(event:NetStatusEvent):void {			trace("Event",event.info.code);			switch (event.info.code) {                case "NetConnection.Connect.Success"	:	trace("Status: Connected.");															//runThis();                    										break;                case "NetConnection.Connect.Rejected"	:	trace("The connection attempt did not have permission to access the application.");                    										break;																		case "NetConnection.Connect.Failed"		:	trace("The connection attempt failed.");                    										break;				case "NetConnection.Call.Failed"		:	trace("The NetConnection.call method was not able to invoke the server-side method or command.");                    										dispatchEvent(new Event("NetConnectionError"));															break;				case ""									:																break;				default									:	trace("Event",event.info.code);															break;															            }        }        private function securityErrorHandler(event:SecurityErrorEvent):void {            trace("securityErrorHandler: " + event);        }				public function close()		{			trace("Killing connection")			connection.close();		}		public function onFault(e)		{			faultCount++;			//trace(faultCount, "Fault in Connector", currCall ,e.type);			resultValueArray.push(null);			if(	resultLabelArray.length == resultValueArray.length)			{				publishResults();			}		}		public function postFault(e)		{			dispatchEvent(new Event("API Fail"));			trace("Fault in Post", e.type);		}		public function cleanUp()		{			removeEventListeners();		}		private function removeEventListeners()		{/*			try			{				if (connection.hasEventListener(Event.COMPLETE))					connection.removeEventListener(Event.COMPLETE, loadConfigInfo);				if (connection.hasEventListener(Event.COMPLETE))					connection.removeEventListener(Event.COMPLETE, loadConfigInfoAndConnect);			 				if (connection.hasEventListener(Event.COMPLETE))					connection.removeEventListener(Event.COMPLETE, getCompDataAfterLoad);									 				if (connection.hasEventListener(NetStatusEvent.NET_STATUS))					connection.removeEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);				if (connection.hasEventListener(SecurityErrorEvent.SECURITY_ERROR))					connection.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);			}			catch(error:Error)			{				trace("Connection Cleanup Error:", error);			}*/			//trace("Cleaning Connector")			for(var i in listenerArray)			{				//trace("Removing:", listenerArray[i].type, "from", listenerArray[i].obj);				listenerArray[i].obj.removeEventListener(listenerArray[i].type, listenerArray[i].listener);			}		}		// Public Methods:		// Protected Methods:	}	}