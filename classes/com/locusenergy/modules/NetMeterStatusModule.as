package com.locusenergy.modules {		import flash.display.*;	import flash.events.*;	import com.locusenergy.meters.*;	import com.locusenergy.Connector;	import flash.net.*;		public class NetMeterStatusModule extends KioskModule{				// Constants:		// Public Properties:		public var componentPath;		public var netMeterComponentName;		public var netMeterInstPowerFunc;		public var netMeterMaxValueFunc;		public var netMeterLoadFunc;		public var netMeterNetFunc;		public var instPower:Number;		public var load:Number;		public var net:Number;		public var powerGen:Number;		public var instPowerMaxValue:Number;		public var loadMaxValue:Number;		public var netMaxValue:Number;		public var netMinValue:Number;		public var meterOutputInst:MeterOutput;		public var meterOutputLoad:MeterOutput;		public var meterOutputNet:MeterOutput;		// Private Properties:		private var instPowerMeter:AnalogMeter;		private var loadMeter:AnalogMeter;		private var netMeter:NetMeter;		private var yPos:Number;		private var gateway;		private var suppressMeters;		//private var grid:Grid;		// Initialization:		public function NetMeterStatusModule(suppress = false) 		{ 			delayLoad = false;			componentName = "NetMeterStatus";			net = 0;						//for using the module to load data without meter sprite overhead			suppressMeters = suppress;			if(!suppressMeters)			{				loadMeters();			}			else			{				triggerData(null);			}		}		override public function getModuleData(connector)		{			this.connector = connector;			this.connector.getComponentData(componentName, loadMeterData)		}		private function loadMeterData()		{			for (var i in connector.resultArray[0])			{					switch (connector.resultArray[0][i].toString())					{						case "instPower" 			:	instPower = connector.resultArray[1][i];														break;						case "instPowerMaxValue" 	:	instPowerMaxValue = connector.resultArray[1][i];														if (!suppressMeters)															{(instPowerMeter as AnalogMeter).setMax(instPowerMaxValue);}														break;						case "load" 				:	load = connector.resultArray[1][i];														break;										case "loadMaxValue" 		:	loadMaxValue = connector.resultArray[1][i];														if (!suppressMeters)															{(loadMeter as AnalogMeter).setMax(loadMaxValue);}														break;							case "net" 					:	net = connector.resultArray[1][i];														break;						case "powerGen" 			:	powerGen = connector.resultArray[1][i];														break;																	case "netMaxValue" 			:	netMaxValue = connector.resultArray[1][i];														if (!suppressMeters)															{(netMeter as NetMeter).setMax(netMaxValue);}														break;						case "netMinValue" 			:	netMinValue = connector.resultArray[1][i];														if (!suppressMeters)															{(netMeter as NetMeter).setMin(netMinValue);}														break;																	}			}			updateMeters();			dispatchEvent(new Event("DataLoaded"));		}		public function loadMeters()		{			yPos = 0;			instPowerMeter 	= new AnalogMeter(instPower, instPowerMaxValue);			instPowerMeter.initializeExternal();			loadMeter 	= new AnalogMeter(load, loadMaxValue);			loadMeter.initializeExternal();			netMeter	= new NetMeter(net, netMaxValue, netMinValue);			//netMeter.addEventListener("MeterLoaded", triggerData, false, 0, true);			netMeter.startLoadMeter();									meterOutputInst = new MeterOutput("INSTANTANEOUS GENERATION", "kW", true);			meterOutputLoad = new MeterOutput("LOAD", "kW", true);			meterOutputNet = new MeterOutput("NET METER", "kW", true);			addChild(meterOutputInst);			addChild(meterOutputLoad);			addChild(meterOutputNet);			addChild(instPowerMeter);			addChild(loadMeter);			addChild(netMeter);						var scale = 0.9;			var spacer = 180;			instPowerMeter.scaleY = scale;			instPowerMeter.scaleX = scale;			loadMeter.scaleY = scale;			loadMeter.scaleX = scale;			netMeter.scaleY = scale;			netMeter.scaleX = scale;				instPowerMeter.x = 20;			instPowerMeter.y = 80;				meterOutputInst.x = instPowerMeter.x;			meterOutputInst.y = instPowerMeter.y + instPowerMeter.height + 25;						meterOutputInst.updateWidth(180);						loadMeter.x = instPowerMeter.x + spacer;						loadMeter.y = 10;			meterOutputLoad.x = loadMeter.x;			meterOutputLoad.y = loadMeter.y + loadMeter.height + 25;						meterOutputLoad.updateWidth(180);						netMeter.x = loadMeter.x + spacer;			netMeter.y = 80;			meterOutputNet.x = netMeter.x;			meterOutputNet.y = netMeter.y + netMeter.height + 25;						meterOutputNet.updateWidth(180);		}		override public function liveUpdate(te)		{			connector.getComponentData(componentName, loadMeterData);		}		private function updateMeters()		{			dispatchEvent(new Event("ModuleUpdated"));			if (!suppressMeters)			{				instPowerMeter.setMeterReading(instPower);				loadMeter.setMeterReading(load);				netMeter.setMeterReading(net);				meterOutputInst.updateMeter(instPower, 40, instPowerMeter.time);				meterOutputLoad.updateMeter(load, 40, loadMeter.time);				meterOutputNet.updateMeter(net, 40, netMeter.time);						}					}		override public function cleanUp()		{			trace("Cleaning NetMeter Module");			cleanUpTimer();			if (instPowerMeter != null)				this.instPowerMeter.cleanUp();			if (loadMeter != null)					this.loadMeter.cleanUp();			if (netMeter != null)					this.netMeter.cleanUp();			if (meterOutputInst != null)				this.meterOutputInst.cleanUp();			if (meterOutputLoad != null)					this.meterOutputLoad.cleanUp();			if (meterOutputNet != null)					this.meterOutputNet.cleanUp();						if (connector != null)				connector.cleanUp();			if (netMeter != null && netMeter.hasEventListener("MeterLoaded"))					netMeter.removeEventListener("MeterLoaded", triggerData);		}	}	}