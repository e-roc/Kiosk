package com.locusenergy.modules {		import flash.display.*;	import flash.events.*;	import com.locusenergy.meters.*;	import com.locusenergy.Connector;	import flash.net.*;		public class CurrentLoadGenModule extends KioskModule{				// Constants:		// Public Properties:		public var componentPath;		public var currentGenComponentName;		public var currentGencurrentLoadFunc;		public var currentGenMaxValueFunc;		public var currentGenloadToDateFunc;		public var maxValue;		//Load  Variables		public var currentLoad;		public var loadToDate;		//Gen Variables		public var instPower;		public var powerGen;		public var recentGen;		// Private Properties:		private var analogMeter:Meter;		private var digitalMeter:Meter;		private var digitalMeter2:ModuleMeterDigital;		private var yPos:Number;		private var connection:NetConnection;		private var gateway;		private var recentGenTitle:String;		public var suppressMeters:Boolean = false;		//private var grid:Grid;		// Initialization:		public function CurrentLoadGenModule(module, suppress = false) 		{ 			componentName = module;			delayLoad = false;			//for using the module to load data without meter sprite overhead			suppressMeters = suppress;			if(!suppressMeters)			{				loadMeters();							}			else			{				triggerData(null);			}		}		override public function getModuleData(connector)		{			trace ("DATA TRIGGERED");			this.connector = connector;			this.connector.getComponentData(componentName, loadMeterData)		}		private function loadMeterData()		{			for (var i in connector.resultArray[0])			{					switch (connector.resultArray[0][i].toString())					{						case "maxValue" 	:	maxValue = connector.resultArray[1][i];												if (!suppressMeters)													{(analogMeter as AnalogMeter).setMax(maxValue);}												break;						case "currentLoad" 	:	currentLoad = connector.resultArray[1][i];												break;						case "loadToDate"	:	loadToDate = connector.resultArray[1][i];												break;						case "powerGen" 	:	powerGen = connector.resultArray[1][i];												break;								case "recentGen"	:	recentGen = connector.resultArray[1][i];												break;						case "recentGenTitle":	recentGenTitle = connector.resultArray[1][i];												digitalMeter2.updateTitle(recentGenTitle);												break;											case "instPower"	:	instPower = connector.resultArray[1][i];												break;					}			}			updateMeters();								}		public function loadMeters()		{			yPos = 0;						if (componentName != "RecentGeneration")			{				analogMeter = new ModuleMeterAnalog();				analogMeter.scaleX = 1;				analogMeter.scaleY = 1;				analogMeter.y = 10;				analogMeter.x = 190;				addChild(analogMeter);			}			else			{				digitalMeter2 = new ModuleMeterDigital(0.0, "test");				digitalMeter2.scaleX = 1;				digitalMeter2.scaleY = 1;				digitalMeter2.y = 10;				digitalMeter2.x = 190;								addChild(digitalMeter2);							}			digitalMeter = new ModuleMeterDigital();			digitalMeter.addEventListener("MeterLoaded", triggerData, false, 0, true);						trace("LISTENING FOR EVENT");			addChild(digitalMeter);			digitalMeter.scaleX = 1;			digitalMeter.scaleY = 1;						digitalMeter.y = 115;			digitalMeter.x = 40;						timerInterval = Meter.MAX_TIME*1000 + 3000;					}				override public function liveUpdate(te)		{			this.connector.getComponentData(componentName, loadMeterData);		}		private function updateMeters()		{			dispatchEvent(new Event("ModuleUpdated"));			if (!suppressMeters)			{				var analogReading;				var digitalReading;				var digitalReading2;				if (componentName == "CurrentLoad")				{					analogReading = currentLoad;					digitalReading = loadToDate;				}				else if (componentName == "CurrentGeneration")				{					analogReading = instPower;					digitalReading = powerGen;				}				else if (componentName == "RecentGeneration")				{					digitalReading2 = recentGen;					digitalReading = powerGen;				}								if (componentName != "RecentGeneration")					analogMeter.setMeterReading(analogReading);				else					digitalMeter2.setMeterReading(digitalReading2);									digitalMeter.setMeterReading(digitalReading);			}			dispatchEvent(new Event("DataLoaded"));		}		override public function cleanUp()		{			trace("Cleaning Current Generation Module");			if (analogMeter != null)				this.analogMeter.cleanUp();			if (digitalMeter != null && digitalMeter.hasEventListener("MeterLoaded"))					digitalMeter.removeEventListener("MeterLoaded", triggerData);				if (digitalMeter != null)					this.digitalMeter.cleanUp();			if (digitalMeter2 != null)					this.digitalMeter2.cleanUp();				if (connector != null)				connector.cleanUp();			removeAllChildren();		}		// Protected Methods:	}	}