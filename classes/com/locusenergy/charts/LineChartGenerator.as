package com.locusenergy.charts {		import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.display.Sprite;	import caurina.transitions.Tweener;	import caurina.transitions.properties.FilterShortcuts;	import flash.filters.BlurFilter;	import flash.text.*;	import flash.utils.Timer;	import flash.geom.Point;		public class LineChartGenerator extends ChartGenerator{				// Constants:		// Public Properties:		public var lines:Array;		public var colors:Array;		public var options:Array;		public var legend:Sprite;		// Private Properties:		private var radius:Number;		private var animTime:Number;		private var hideLineTimer:Timer;				// Initialization:		public function LineChartGenerator(cWidth, cHeight, titleX, titleY, titleY2, maxX, maxY, maxY2, vertTicks, type, minY, total, totalStr = "generation", msg:String ="")  {			FilterShortcuts.init();			setUpcolors();			var yaxiscolor;			this.total = total;			this.msg = msg;			if (maxY2 == 0)			{				secondYAxisFlag = false;				cWidth = cWidth + 120;			}			if (maxY2 == 0)				yaxiscolor = 0xffffff;			else				yaxiscolor = colors[0]			drawGridForLine(cWidth, cHeight, titleX, titleY, titleY2, maxX, maxY, maxY2, vertTicks, type, yaxiscolor, colors[1], minY, totalStr);			this.maxY2 = maxY2			lines = new Array();			hideLineTimer = new Timer(5000);			hideLineTimer.addEventListener(TimerEvent.TIMER, timesUp, false, 0 , true);			animTime = 0.13;			radius = 4;			grid.y = 50;		}		override public function drawGrid()		{			grid.setGrid(w, h, xMax, yMax, horizTickInterval, vertTickInterval, xTitle.toUpperCase(), yTitle.toUpperCase(), type);			grid.drawGridForLine(w, h, xMax, yMax, maxY2, horizTickInterval, vertTickInterval, xTitle.toUpperCase(), yTitle.toUpperCase(), yTitle2.toUpperCase(), type, color1, color2, yMin);			addChild(grid);			setRatios();		}		private function setUpcolors()		{			colors = new Array();			colors.push(0x65db28);			colors.push(0x1bb5ff);			colors.push(0xff4e02);			colors.push(0x69a10f);			colors.push(0x0977DB);			colors.push(0xe57e00);			colors.push(0x91c345);						colors.push(0x5084ba);			colors.push(0xdbb041);			colors.push(0xc7ed8b);			colors.push(0xa4c4e3);			colors.push(0xf9e16e);										}		override public function deselectAll()		{		}				public function hideLine(i)		{			var blurOn = new BlurFilter(8,12,2);			var t = 0.7;			Tweener.addTween(lines[i],{_filter:blurOn, alpha:0, time:t});			Tweener.addTween(lines[i],{y: lines[i].y + 1000 , alpha:0, delay:t, time:0.0, onComplete: restoreListener, onCompleteParams:[i]});		}		private function restoreListener(i)		{			options[i].addEventListener(MouseEvent.CLICK, hideOtherLines);		}		var selectedIndex = 0;		public function hideOtherLines(me:MouseEvent)		{			hideLineTimer.reset();			hideLineTimer.start();			showAllLines();						for(var i in lines)			{				if (options[i] != me.currentTarget) 				{					hideLine(i);				}				else				{					selectedIndex = i;				}				options[i].removeEventListener(MouseEvent.CLICK, hideOtherLines);							}		}				public function timesUp(te:TimerEvent)		{			hideLineTimer.stop();			showAllLines();		}		public function showAllLines()		{			restoreListener(selectedIndex);			var blurOff = new BlurFilter(0,0,0);			for(var j in lines)			{				if (lines[j].y >= 1000)					lines[j].y = lines[j].y - 1000;				Tweener.addTween(lines[j], {_filter: blurOff, alpha:1, time:0.8});			}		}		override public function generateLegend(titles:Array)		{			legend = new Sprite();						options = new Array();			var fmt = new TextFormat("Gotham Narrow Book", 12, colors[0]);			var posX = 0;			var spacer = 10;						for (var i in lines)			{				var lineLength = w/(lines.length * 2.2);				if (lineLength > 50) lineLength = 50; 				var option:Sprite = new Sprite();				var text:TextField = new TextField();				fmt.color 				= 	colors[i];				text.defaultTextFormat 	= 	fmt;				text.embedFonts 		= 	true;				text.antiAliasType 	= 	AntiAliasType.ADVANCED;				text.y					=	-8;				text.x					=	posX + lineLength + spacer;				text.autoSize			= 	"left";				text.text				=	"";								if(i < titles.length)					{					text.text = titles[i];				}				option.graphics.lineStyle(9, colors[i], 1.0, true,"normal","square");				option.graphics.moveTo(posX,0);				option.graphics.lineTo(posX + lineLength,0);				option.addChild(text);								option.addEventListener(MouseEvent.CLICK, hideOtherLines, false, 0, true);				legend.addChild(option);				options.push(option);								posX  = posX + option.width + spacer;			}			legend.x = 0			legend.y = -h*0.1 + 50;			addChild(legend);		}				override public function generateLine(k)		{			var ratio;			var line = new Line();			if (k == 1 && secondYAxisFlag)				ratio = heightRatio2;			else				ratio = heightRatio;			line.color = colors[k];				for (var i=0; i<ptsArray.length; i++)			{				var ptHeight:Number = h + grid.y - (ptsArray[i].yVal * ratio) - (Math.abs(yMin) * ratio);				//For first two lines, infobubble color has gradient				if (k == 0 || k == 1)					ptsArray[i].bubbleColor = k;				else						ptsArray[i].bubbleColor = colors[k];  //remaining lines use solid color									ptsArray[i].graphics.beginFill(colors[k]);				ptsArray[i].graphics.drawCircle(0, 0, radius);				ptsArray[i].graphics.beginFill(colors[k],0.0);				ptsArray[i].graphics.drawCircle(0, 0, radius*3);				ptsArray[i].graphics.endFill();					ptsArray[i].x = (ptsArray[i].xVal + 1) * widthRatio;								if (this.type == "hours")				{					ptsArray[i].x = (ptsArray[i].xVal +2) * widthRatio;									}								ptsArray[i].y = ptHeight;				ptsArray[i].addEventListener(MouseEvent.CLICK, displayInfo, false, 0 , true);				ptsArray[i].type = lines.length;			}			line.ptsArray = ptsArray;			lines.push(line);		}		override public function animateLines()		{			for (var i in lines)			{				var lineMask = new Sprite();				var lineDraw = new Sprite();				addChild(lineMask);				addChild(lines[i]);				lines[i].mask = lineMask;								lineMask.graphics.beginFill(0xffffff);				lineMask.graphics.drawRect(0,-7,1,h+14);				lineMask.graphics.endFill();				lineMask.x = -7;				lineMask.y = grid.y;								lines[i].graphics.beginFill(0xffffff);				lines[i].graphics.lineStyle(2, lines[i].color, 0.8);				lines[i].graphics.moveTo(lines[i].ptsArray[0].x, lines[i].ptsArray[0].y);				lines[i].graphics.endFill();								for(var j in lines[i].ptsArray)				{					lines[i].graphics.lineTo(lines[i].ptsArray[j].x, lines[i].ptsArray[j].y);					animatePoint(lines[i],lines[i].ptsArray[j], j);				}				Tweener.addTween(lineMask, {width: w + 14, time: 0.5 * animTime * lines[i].ptsArray.length, transition: "linear"});			}		}		private function drawIntegral()		{			//only works for two lines				var integral:Sprite = new Sprite();								integral.graphics.beginFill(0xffffff, 0.2);				integral.graphics.lineStyle(2, 0xCC0000, 0.8);				var len = (lines[0].ptsArray.length > lines[1].ptsArray.length?lines[1].ptsArray.length:lines[0].ptsArray.length)				var pt = choosePoint(lines[0].ptsArray[0], lines[1].ptsArray[0], true);				integral.graphics.moveTo(pt.x, pt.y);																for(var j = 1; j < len; j++)				{					pt = choosePoint(lines[0].ptsArray[j], lines[1].ptsArray[j], true);					integral.graphics.lineTo(pt.x, pt.y);				}								for(var k = len - 1 ; k >= 0 ; k--)				{					pt = choosePoint(lines[0].ptsArray[k], lines[1].ptsArray[k], false);					integral.graphics.lineTo(pt.x, pt.y);				}								integral.graphics.endFill();								addChild(integral);				}		private function choosePoint(pt1, pt2, highFlag):Point		{			var pt;						if (highFlag)				pt = (pt1.y <= pt2.y ? pt1 : pt2);			else				pt = (pt1.y < pt2.y ? pt2 : pt1);			return new Point(pt.x, pt.y);						}		public function animatePoint(parentSprite, pt:Pt, i)		{			var t = animTime;			var del = 0.5 * t * i;			pt.alpha = 0;			pt.scaleX = 0.1			pt.scaleY = 0.1;			parentSprite.addChild(pt);						Tweener.addTween(pt, {scaleX: 1, scaleY: 1, alpha: 1, delay: del, time: t});					}			override protected function removeLinkEventListeners()		{			for (var i in lines)			{				for (var j=0 in lines[i].ptsArray.length)				{					lines[i].ptsArray[j].removeEventListener(MouseEvent.CLICK, displayInfo);				}			}			for (var k in options)			{				options[k].removeEventListener(MouseEvent.CLICK, hideOtherLines);			}			if (hideLineTimer.hasEventListener(TimerEvent.TIMER))	hideLineTimer.removeEventListener(TimerEvent.TIMER, timesUp);		}	}	}