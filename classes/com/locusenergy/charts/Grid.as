package com.locusenergy.charts{		import flash.display.*;	import flash.geom.Matrix;	import flash.text.*;	import flash.filters.GlowFilter;	import com.locusenergy.AssetCache;	import com.locusenergy.CrankCommas;		public class Grid extends Sprite{			// Constants:		// Public Properties:		public var theGrid:Sprite;		public var labelConversion:Conversion = new Conversion();		// Private Properties:		public var gridWidth:Number;		public var gridHeight:Number;		private var segmentsHor:Number;		private var segmentsVert:Number;		private var horizTickInterval:Number;		private var vertTickInterval:Number;		private var textFormat:TextFormat;		private var textField:TextField;		private var xMax;		private var yMax;		private var yMin;		private var y2Max;		private var xLabel;		private var yLabel;		private var y2Label = "";		private var lblType;		private var yAxis1Color = 0xffffff;		private var yAxis2Color = 0xffffff;		private var dayOffset;		private var monthOffset;		private var SecondYAxisFlag:Boolean = false;		private var horizSpacing;		private var vertSpacing;		// Initialization:		public function Grid()		{			if (AssetCache.hideDayView)				labelConversion.yesterday();			theGrid = new Sprite();		}		public function setGrid(width:Number, height:Number, maxX:int, maxY:int, iteratorX:Number, iteratorY:Number, xLabel:String, yLabel:String, labelType, minY:Number = 0)		{			gridWidth = width;			gridHeight = height;			segmentsHor = Math.ceil(maxX/iteratorX) + 1;			segmentsVert = (maxY - minY)/iteratorY;			xMax = maxX;			yMax = maxY;			yMin = minY			horizTickInterval = iteratorX;			vertTickInterval = iteratorY;			horizSpacing = gridWidth/segmentsHor;			vertSpacing = gridHeight/segmentsVert;			lblType = labelType;			this.xLabel = xLabel;			this.yLabel = yLabel;			textFormat = new TextFormat("Gotham Narrow Book", Math.floor(gridWidth * 0.025), 0xffffff);								}		public function drawGrid()		{			theGrid = new Sprite();			while(this.numChildren)			{				this.removeChildAt(0);			}			drawBg();						drawVerticalLines();			drawHorizontalLines();						addChild(theGrid);			xAxisTitle(xLabel);			yAxisTitle(yLabel);			if (y2Max != 0)				yAxis2Title(y2Label);		}		public function drawGridForLine(width:Number, height:Number, maxX:int, maxY:int, maxY2:int, iteratorX:Number, iteratorY:Number, xLabel:String, yLabel:String, y2Label:String, labelType, color1, color2, minY:Number=0)		{						setYaxisColors(color1, color2);			y2Max = maxY2;			if (maxY2 == 0)				SecondYAxisFlag = false;			else				SecondYAxisFlag = true;							this.y2Label = y2Label;			setGrid(width, height, maxX, maxY, iteratorX, iteratorY, xLabel, yLabel, labelType, minY);			drawGrid();					}		public function drawBg()		{				var bg:Sprite = new Sprite();			var glowFilter:GlowFilter 	= new GlowFilter(0x000000, 0.3, 20.0, 30.0, 4.0,1,false);			glowFilter.blurX			= 20.0;			glowFilter.blurY			= 30.0;			glowFilter.strength			= 4;			glowFilter.alpha			= 0.5;			glowFilter.quality			= 9;						var matrix:Matrix = new Matrix();			var colorsArray = new Array(0x000000, 0x000000);			var alphasArray = new Array(0.4, 0.0);			var ratiosArray = new Array(0,200);						matrix.createGradientBox( gridWidth, gridHeight,-Math.PI/4);			bg.graphics.beginGradientFill("linear",colorsArray, alphasArray, ratiosArray, matrix, SpreadMethod.PAD, InterpolationMethod.LINEAR_RGB);			bg.graphics.drawRect(0,0,gridWidth, gridHeight);			bg.graphics.endFill();			bg.filters = new Array(glowFilter);						theGrid.addChild(bg);		}		public function drawVerticalLines()		{			var days;			var months;			var years;			var hours;												switch (lblType)			{				case "months"		:	months = labelConversion.getMonthsArray();										break;				case "days"			:	days = labelConversion.getDaysOfMonthArray();										break;				case "weekdays"		:	days = labelConversion.getWeekdaysArray();										break;				case "life-months"	: 	months = labelConversion.getLifeMonthsArray(xMax);										break;				case "life-years"	: 	years = labelConversion.getLifeYearsArray(xMax);										break;				case "hours"		: 	hours = labelConversion.getHoursArray();										break;			}						var tickMarkLength = gridHeight/20;			for(var i=0; i <= segmentsHor; i++)			{				theGrid.graphics.lineStyle(1,0xffffff,0.2);				theGrid.graphics.moveTo(i*horizSpacing,0);				if (i != segmentsHor) {theGrid.graphics.lineTo(i*horizSpacing, gridHeight);}				else {theGrid.graphics.moveTo(i*horizSpacing, gridHeight);}				var labelPosX =	i*horizSpacing  - tickMarkLength;				var labelPosY = gridHeight + tickMarkLength;								if (horizTickInterval*i <= xMax) 				{					theGrid.graphics.lineStyle(1,0xffffff,0.4);					theGrid.graphics.lineTo(labelPosX, labelPosY);				}				//x-Axis labels				if (lblType == "months")				{					if (i<segmentsHor-1)					{						labelPosX = labelPosX + (0.7*horizSpacing);						if (i < months.length)						{							createLabel(labelPosX, labelPosY, months[i].shortName, 0, 0);						}					}				}				else if (lblType == "hours")				{					if (i >= 1 && i < segmentsHor)					{						labelPosX = labelPosX - (0.4 * horizSpacing);						createLabel(labelPosX, labelPosY, hours[i * horizTickInterval].shortName, 0, 0);					}				}				else if (lblType == "life-months")				{					if (i<segmentsHor-1)					{						labelPosX = labelPosX + (0.7*horizSpacing);						createLabel(labelPosX, labelPosY, months[i].shortName, 0, 0);					}				}				else if (lblType == "life-years")				{					if (i<segmentsHor-1)					{						labelPosX = labelPosX + (0.7*horizSpacing);						createLabel(labelPosX, labelPosY, years[i].shortName, 0, 0);					}				}				else if (lblType == "weekdays")				{					if (i<segmentsHor-1)					{						if (i < days.length)						labelPosX = labelPosX + (horizSpacing*0.7);						createLabel(labelPosX, labelPosY, days[i].shortName, 0, 0);					}				}				else if (lblType == "days")				{					if (horizTickInterval*i <= xMax && i>0)	createLabel(labelPosX, labelPosY, days[horizTickInterval * i].shortName, -horizSpacing * 0.7, 1.1 * vertSpacing, "X" ,-45);					//if(days[horizTickInterval*i] == 2 || days[horizTickInterval*i] == 1)		createMonthLabel(labelPosX, labelPosY, -horizSpacing/4);				}				else if (i != 0)				{					if (horizTickInterval*i <= xMax)	createLabel(labelPosX, labelPosY, horizTickInterval*i, - horizSpacing/4 , 0);				}			}					}		private function drawZeroLine(){			var zeroHeight = gridHeight - Math.abs(yMin) * (gridHeight/(yMax - yMin));						theGrid.graphics.lineStyle(1,0xff0000,0.8);			theGrid.graphics.moveTo(gridWidth, zeroHeight);			theGrid.graphics.lineTo(0, zeroHeight);			}		public function drawHorizontalLines()		{			var vertTickInterval2 = y2Max/segmentsVert;			var tickMarkLength = gridHeight/20;			if (yMin < 0)	drawZeroLine();			for(var i=0; i <= segmentsVert; i++)			{				theGrid.graphics.lineStyle(1,0xffffff,0.2);				theGrid.graphics.moveTo(gridWidth, gridHeight - i*vertSpacing);				if (i != segmentsVert)	theGrid.graphics.lineTo(0, gridHeight - i*vertSpacing);				else theGrid.graphics.moveTo(0, gridHeight - i*vertSpacing);								var labelPosX = -tickMarkLength;				var labelPosY =  gridHeight - i*vertSpacing + tickMarkLength;				if (i != 0 || yMin != 0)				{					theGrid.graphics.lineStyle(1,0xffffff,0.4);					//y-Axis labels					if((i%2) == 0)						{						theGrid.graphics.lineTo(labelPosX, labelPosY);						//CrankCommas.crankComma((Math.ceil(yMin + (vertTickInterval*i))).toString())						//if()						var lblVal=yMin + (vertTickInterval*i);						if (lblVal >= 1 || lblVal <= -1)	{lblVal = Math.ceil(lblVal);}						else {lblVal = lblVal.toFixed(1);}						createLabel(labelPosX, labelPosY, CrankCommas.crankComma(lblVal.toString()), -(0.5 * tickMarkLength), -(vertSpacing*.3), "Y");					}					else					{						theGrid.graphics.lineTo(labelPosX + tickMarkLength/2, labelPosY - tickMarkLength/2);					}					if(SecondYAxisFlag && (i%2) == 0) 					{						createLabel(gridWidth, labelPosY, vertTickInterval2*i, 0.55 * tickMarkLength, 0, "X")					}				}				else if (i == 0)				{					createLabel(labelPosX, labelPosY, 0, -(0.5 * tickMarkLength), -(vertSpacing*.3), "Y");				}			}					}		private function createMonthLabel(posX, posY, xOffset)		{			var months = labelConversion.getMonthsArray();			var month = months[months.length -1].longName;			var yOffset = .08 * gridHeight;			textField = new TextField();			textField.antiAliasType = AntiAliasType.ADVANCED;			textField.text = month;			textField.embedFonts = true;			textField.selectable = false;			textField.autoSize = TextFieldAutoSize.RIGHT;			textFormat.color = 0x2251a0;			textField.setTextFormat(textFormat);			textFormat.color = 0xffffff;			textField.x = posX + xOffset;			textField.y = posY + yOffset;			theGrid.addChild(textField);		}				public function createLabel(posX, posY, label, xOffset, yOffset, axis = "X", rotation = 0)		{			var size = gridWidth/segmentsHor * 0.40;			if (size > gridWidth * 0.02)			{				size = gridWidth * 0.02;			}			textField = new TextField();			textFormat.size = size;			textField.antiAliasType = AntiAliasType.ADVANCED;			textField.text = label;			textField.embedFonts = true;			textField.selectable = false;				textField.x = posX + xOffset;			textField.y = posY + yOffset;			if (axis == "X")			{				textFormat.align = TextFormatAlign.RIGHT;				textField.autoSize = TextFieldAutoSize.LEFT;			}			else if (axis == "Y")			{				textFormat.align = TextFormatAlign.RIGHT;				textField.autoSize = TextFieldAutoSize.RIGHT;				textField.x = posX + xOffset - textField.width;				textField.y = posY + yOffset;			}			textField.setTextFormat(textFormat);				textField.rotation = rotation;			theGrid.addChild(textField);		}		public function xAxisTitle(title)		{			textFormat.size = gridWidth * 0.030;			textField = new TextField();			textField.antiAliasType = AntiAliasType.ADVANCED;			textField.autoSize = "center";			textField.defaultTextFormat = textFormat;			if (title != null) textField.htmlText = title;			textField.selectable = false;			textField.embedFonts = true;			textField.x = gridWidth/2 - textField.width/2;			textField.y = gridHeight*1.19;			theGrid.addChild(textField);		}		public function setYaxisColors(color1, color2)		{			yAxis1Color = color1;			yAxis2Color = color2;		}		public function yAxisTitle(title)		{			//retains size from xAxisTitle			textField = new TextField();			textField.antiAliasType = AntiAliasType.ADVANCED;			textField.selectable = false;			textField.autoSize = TextFieldAutoSize.LEFT;			textFormat.align = TextFormatAlign.LEFT;			textFormat.color = yAxis1Color;			textField.defaultTextFormat = textFormat;			if (title != null) textField.text = title;			textField.embedFonts = true;			textField.y = gridHeight/2 + textField.width/2;			textField.x = 0 - (gridWidth * 0.15);			//shift grid			textField.rotation = -90;									theGrid.addChild(textField);		}		public function yAxis2Title(title)		{			//retains size from xAxisTitle			textField = new TextField();			textField.antiAliasType = AntiAliasType.ADVANCED;			textField.autoSize = TextFieldAutoSize.LEFT;			textField.selectable = false;			textFormat.align =TextFormatAlign.LEFT;			textFormat.color = yAxis2Color;			textField.defaultTextFormat = textFormat;			textField.text = title;			textField.embedFonts = true;			textField.y = gridHeight/2 + textField.width/2;			textField.x = gridWidth + (gridWidth * 0.1);			//shift grid			textField.rotation = -90;			theGrid.addChild(textField);		}	}	}