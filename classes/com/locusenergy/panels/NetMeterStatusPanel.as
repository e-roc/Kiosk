package com.locusenergy.panels {		import flash.display.*;	import flash.events.*;	import com.locusenergy.meters.*;	import com.locusenergy.Connector;	import flash.net.*;		public class NetMeterStatusPanel extends Panel{				// Constants:		// Public Properties:		public var componentPath;		public var netMeterComponentName;		public var netMeterInstPowerFunc;		public var netMeterMaxValueFunc;		public var netMeterLoadFunc;		public var netMeterNetFunc;		public var instPower:Number;		public var load:Number;		public var net:Number;		public var powerGen:Number;		public var instPowerMaxValue:Number;		public var loadMaxValue:Number;		public var netMaxValue:Number;		public var netMinValue:Number;		public var meterOutputInst:MeterOutput;		public var meterOutputLoad:MeterOutput;		public var meterOutputNet:MeterOutput;		// Private Properties:		private var instPowerMeter:AnalogMeter;		private var loadMeter:AnalogMeter;		private var netMeter:NetMeter;		private var yPos:Number;		private var gateway;		private var componentName;		//private var grid:Grid;		// Initialization:		public function NetMeterStatusPanel(connector, nodes = null) 		{ 			initializeMeters();			this.connector = connector;			componentName = "NetMeterStatus";			paramArray["nodes"] = nodes;			triggerData(null);			loadMeters();		}		private function triggerData(e)		{			trace("TRIGGER DATA LOAD", componentName, paramArray);			this.connector.getComponentData(componentName, loadMeterData, paramArray);		}		private function initializeMeters()		{			instPowerMeter 	= new AnalogMeter(instPower, instPowerMaxValue);			instPowerMeter.initializeExternal();			loadMeter 	= new AnalogMeter(load, loadMaxValue);			loadMeter.initializeExternal();			netMeter	= new NetMeter(net, netMaxValue, netMinValue);						netMeter.startLoadMeter();			//netMeter.addEventListener("MeterLoaded", triggerData, false, 0, true);									meterOutputInst = new MeterOutput("INSTANTANEOUS GENERATION", "kW", true);			meterOutputLoad = new MeterOutput("LOAD", "kW", true);			meterOutputNet = new MeterOutput("NET METER", "kW", true);		}		private function loadMeterData()		{			for (var i in connector.resultArray[0])			{				switch (connector.resultArray[0][i].toString())				{					case "instPower" 			:	instPower = connector.resultArray[1][i];													break;					case "instPowerMaxValue" 	:	instPowerMaxValue = connector.resultArray[1][i];													if (instPowerMeter != null)	(instPowerMeter as AnalogMeter).setMax(instPowerMaxValue);													break;					case "load" 				:	load = connector.resultArray[1][i];													break;									case "loadMaxValue" 		:	loadMaxValue = connector.resultArray[1][i];														if (loadMeter != null) (loadMeter as AnalogMeter).setMax(loadMaxValue);													break;						case "net" 					:	net = connector.resultArray[1][i];													break;					case "powerGen" 			:	powerGen = connector.resultArray[1][i];													break;																case "netMaxValue" 			:	netMaxValue = connector.resultArray[1][i];													if (netMeter != null) (netMeter as NetMeter).setMax(netMaxValue);													break;					case "netMinValue" 			:	netMinValue = connector.resultArray[1][i];													(netMeter as NetMeter).setMin(netMinValue);													break;					case "nodes"				:	trace("Nodes set to", connector.resultArray[1][i]);													break;												}			}			dispatchEvent(new Event("DataLoaded"));			updateMeters();		}		public function loadMeters()		{			yPos = -80;			var xPos = 182;			var scale = 1.5;			var spacer = 305;			addChild(meterOutputInst);			addChild(meterOutputLoad);			addChild(meterOutputNet);			addChild(instPowerMeter);			addChild(loadMeter);			addChild(netMeter);			instPowerMeter.scaleY = scale;			instPowerMeter.scaleX = scale;			loadMeter.scaleY = scale;			loadMeter.scaleX = scale;			netMeter.scaleY = scale;			netMeter.scaleX = scale;				instPowerMeter.x = xPos;			instPowerMeter.y = yPos + 150;				meterOutputInst.x = instPowerMeter.x + 60;			meterOutputInst.y = instPowerMeter.y + instPowerMeter.height + 40;						meterOutputInst.updateWidth(180);						loadMeter.x = instPowerMeter.x + spacer;						loadMeter.y = yPos;			meterOutputLoad.x = loadMeter.x + 60;			meterOutputLoad.y = loadMeter.y + loadMeter.height + 40;						meterOutputLoad.updateWidth(180);						netMeter.x = loadMeter.x + spacer;			netMeter.y = yPos + 150;			meterOutputNet.x = netMeter.x + 60;			meterOutputNet.y = netMeter.y + netMeter.height + 40;						meterOutputNet.updateWidth(180);						if (timerInterval < Meter.MAX_TIME*1000)				timerInterval = Meter.MAX_TIME*100			poll();		}		override protected function liveUpdate(e)		{			connector.getComponentData(componentName, loadMeterData);		}		private function updateMeters()		{			dispatchEvent(new Event("MeterUpdated"));						instPowerMeter.setMeterReading(instPower);			loadMeter.setMeterReading(load);			netMeter.setMeterReading(net);			meterOutputInst.updateMeter(instPower, 40, instPowerMeter.time);			meterOutputLoad.updateMeter(load, 40, loadMeter.time);			meterOutputNet.updateMeter(net, 40, netMeter.time);					}		override protected function removeAdditionalEventHandlers()		{			trace("Cleaning NetMeter Module");			if (instPowerMeter != null)				this.instPowerMeter.cleanUp();			if (loadMeter != null)					this.loadMeter.cleanUp();			if (netMeter != null)					this.netMeter.cleanUp();			if (meterOutputInst != null)				this.meterOutputInst.cleanUp();			if (meterOutputLoad != null)					this.meterOutputLoad.cleanUp();			if (meterOutputNet != null)					this.meterOutputNet.cleanUp();						if (connector != null)				connector.cleanUp();			if (netMeter.hasEventListener("MeterLoaded"))				netMeter.removeEventListener("MeterLoaded", triggerData);			removeAllChildren();		}		// Protected Methods:	}	}